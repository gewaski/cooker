/*
 * Copyright(c) 2016 zhangwei13 <alucard.hust@gmail.com>
 * 
 * Cooker
 *
 * MIT License
 */

function Cooker() {

    var queue = [];
    var started = false;

    this.addAction = addAction;
    this.addBatchActions = addBatchActions;
    this.addCheckAction = addCheckAction;
    this.on = on;
    this.off = off;
    this.queue = queue;


    /*
     * add action
     * action(markDone) should call markDone.done() when finished
     */
    function addAction(action, sleep, name) {
        queue.push([action, sleep, name]);
    }

    /*
     * add actions
     * action(markDone) should call markDone.done() when finished
     */
    function addBatchActions() {
        if (arguments.length%3 != 0) {
            console.log("[cooker addBatchActions]: nvalid arguments: [action1, action1SleepMills, action1Name, action2, action2SleepMills, action2Name ...]");
            return;
        }
        for (var i=0; i<arguments.length; i+=3) {
            queue.push([arguments[i], arguments[i+1], arguments[i+2]]);
        }
    }

    function checkExecute(action, markDone, checkFunc, checkInterval) {
        setTimeout(function(){
            if (checkFunc()) {
                if (typeof action == 'function') {
                    action();
                }
                markDone.done();
            } else {
                checkExecute(action, markDone, checkFunc, checkInterval);
            }
        }, checkInterval);
    }

    /*
     * action with checkFunc, if checkFunc = true, markDone is done,
     * so there is no need for _action to call markDone
     */
    function addCheckAction(action, sleep, name, checkFunc, checkInterval) {
        var _action = function(markDone) {
            checkExecute(action, markDone, checkFunc, checkInterval);
        };
        addAction(_action, sleep, name);
    }


    /*
     * start *cooking*
     * one cooker could accept more actions after cooker startActions,
     * it's useful in appending more tasks generated by previous tasks, 
     * just like spider/crawler
     */
    function on() {
        started = true;
        startActions();
    }

    function off() {
        started = false;
    }

    function startActions() {

        function MarkDone() {

            var flag = [];

            this.done = function() {
                flag.pop();
            }
            this.start = function() {
                flag.push(1);
            }
            this.isDone = function() {
                return 0 == flag.length;
            }
        }

        markDone = new MarkDone();

        // sleep and run, action should call markDone.done() when finished
        function sleepRun(action, sleep) {
            markDone.start();
            setTimeout(function(){
                action(markDone);
            }, sleep);
        }

        // run multi actions in sequence
        function runAction() {

            if (!started) {
                return;
            }

            if (0 != queue.length) {
                console.log("******[start action]: " + queue[0][2]);
                qitem = queue.shift();
                sleepRun(qitem[0], qitem[1]);
            }
    
            var interval = setInterval(function () {
                if (markDone.isDone()) {
                    clearInterval(interval);
                    if (0 <= queue.length) {
                        if (0 != queue.length) {
                            console.log("******[try to trigger next action]: " + queue[0][2]);
                        }
                        runAction();
                    }
                }
            }, 1);
        }
        runAction();
    };
}

module.exports.create = function(){return new Cooker();};
